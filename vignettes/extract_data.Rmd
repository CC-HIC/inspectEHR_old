---
title: "How to extract data using inspectEHR"
author: "Edward Palmer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

inspectEHR contains a number of helper functions for wrangling data. These will be ported over to cleanEHR to keep the roles of the two packages clear.

```{r install_inspectEHR}
# If you need inspectEHR
# library(devtools)
# install_github("CC-HIC/inspectEHR", ref = "postgres")

library(tidyverse)
library(inspectEHR) # note extract is masked by tidyverse
```

I strongly advise running tidyverse. Whilst you don't need it, inspectEHR has been written with tidyeval in mind, and as such works best in the tidyverse ecosystem.

Establish a database connection. You will most likely be working with sqlite as the postgres instance is confined to the UCL IDHS.

```{r db_connect}
# Establish a DB connection and retrive tables
ctn <- connect(system = "sqlite", file = "~/Documents/_data/hic/public_release_20180914.sqlite3")
tbls <- retrieve_tables(ctn)
```

Enter the fields you want to extract using HIC codes. See the cleanEHR repo for more information on these codes. I write this here as a tribble just to keep everything in the same document.

It's best to separate out 1d and 2d data.

```{r define codes}
# Grab non-longitudinal (1d) data ----------------
demo_codes <- tribble(
  ~hic_codes, ~short_name,
  "NIHR_HIC_ICU_0399", "primary_admission_reason",
  "NIHR_HIC_ICU_0088", "secondary_admission_reason",
  "NIHR_HIC_ICU_0068", "location_in",
  "NIHR_HIC_ICU_0398", "admission_type",
  "NIHR_HIC_ICU_0004", "treatment_code",
  "NIHR_HIC_ICU_0011", "pre_surgical_prep",
  "NIHR_HIC_ICU_0027", "surgical_classification",
  "NIHR_HIC_ICU_0409", "apache_score",
  "NIHR_HIC_ICU_0055", "prior_dependency",
  "NIHR_HIC_ICU_0058", "ethnicity",
  "NIHR_HIC_ICU_0033", "dob",
  "NIHR_HIC_ICU_0019", "weight",
  "NIHR_HIC_ICU_0021", "cpr",
  "NIHR_HIC_ICU_0093", "sex",
  "NIHR_HIC_ICU_0094", "organ_donor",
  "NIHR_HIC_ICU_0103", "withdrawal",
  "NIHR_HIC_ICU_0097", "unit_mortality",
  "NIHR_HIC_ICU_0095", "hospital_mortality"
)

## Extract 1d data
dtb <- extract_demographics(metadata = tbls[["variables"]],
                            events = tbls[["events"]],
                            codes = demo_codes$hic_codes)

## Rename
replacement_names <- demo_codes$short_name[
  match(names(dtb), demo_codes$hic_codes)]

names(dtb) <- if_else(
  is.na(replacement_names), names(dtb), replacement_names)

## Tidy up
rm(replacement_names)

# Grab longitudinal (2d) data ---------------------
long_codes <- tribble(
  ~hic_codes, ~short_name,
  "NIHR_HIC_ICU_0411", "start_dttm", # ALWAYS
  "NIHR_HIC_ICU_0150", "fio2",
  "NIHR_HIC_ICU_0470", "norad",
  "NIHR_HIC_ICU_0132", "pxo2")
```

We can now extact 2d data. This will return a table with 1 row per patient per time unit specified in the cadance option. For example, a cadance of 1 will return a table with 1 row per patient per hour. This will be a complete (non-sparse) table, so if nothing was recorded for a partiular hour, that hour will not appear as a row.

```{r extract_timevarying}
ltb <- extract_timevarying(
  events = tbls[["events"]] %>%
    filter(code_name %in% long_codes$hic_codes),
  metadata = collect(tbls[["variables"]]),
  chunk_size = 1000,
  cadance = 1)

# I recomend saving here... depending on how much data you are trying to wrangle, that step can take a long time.
save(dtb, ltb, demo_codes, long_codes, file = "./backup.RData")

replacement_names <- long_codes$short_name[
  match(names(ltb), long_codes$hic_codes)]

names(ltb) <- if_else(
  is.na(replacement_names), names(ltb), replacement_names)

rm(replacement_names)

# Expand this dense tb (i.e. add NAs where appropraite)
ltb <- expand_missing(ltb)
```

expand_missing serves to fill in the gaps with NAs so the table haas a regular cadance.
